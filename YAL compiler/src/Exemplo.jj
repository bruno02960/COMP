options
{
 LOOKAHEAD=1;
}

PARSER_BEGIN(Exemplo)

//código Java que invoca o parser 
public class Exemplo 
{ 
	public static void main(String args[]) throws ParseException 
	{ 
		//criação do objecto utilizando o constructor com argumento para 
		//ler do standard input (teclado) 
		Exemplo parser = new Exemplo(System.in); 
		//parser.Aritm();

	}
}

PARSER_END(Exemplo)

// definição dos tokens (símbolos terminais) 
<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}
/*
//Non-terminals
Module ::= <MODULE> <ID> <LCHAVETA> ( Declaration )* ( Function )* <RCHAVETA>
Declaration ::= ( ArrayElement | ScalarElement ) ( <ASSIGN> ( ( "[" ArraySize "]" ) | (<ADDSUB_OP> )? <INTEGER> ) )? <PVIRG>
Function ::= ( ( <FUNCTION> ( ArrayElement | ScalarElement ) <ASSIGN> <ID> <LPAR> (Varlist )? <RPAR> ) | ( <FUNCTION> <ID> <LPAR> ( Varlist )? <RPAR> ) )<LCHAVETA> Stmtlst <RCHAVETA>
Varlist ::= ( ArrayElement | ScalarElement ) ( <VIRG> ( ArrayElement | ScalarElement ))*
ArrayElement ::= <ID> "[" "]"*/


/*ScalarElement ::= <ID>*/
void ScalarElement(): { }
{
  < ID >
}

/*
Stmtlst ::= ( Stmt )*
Stmt ::= While | If | Assign | Call <PVIRG>
Assign ::= Lhs <ASSIGN> Rhs <PVIRG>
Lhs ::= ArrayAccess | ScalarAccess
Rhs ::= ( Term ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term )? ) | "[" ArraySize "]"
ArraySize ::= ScalarAccess | <INTEGER>
Term ::= ( <ADDSUB_OP> )? ( <INTEGER> | Call | ArrayAccess | ScalarAccess )
Exprtest ::= <LPAR> Lhs <RELA_OP> Rhs <RPAR>
While ::= <WHILE> Exprtest <LCHAVETA> Stmtlst <RCHAVETA>
If ::= <IF> Exprtest <LCHAVETA> Stmtlst <RCHAVETA> ( <ELSE> <LCHAVETA> Stmtlst <RCHAVETA> )?
Call ::= <ID> ( "." <ID> )? <LPAR> ( ArgumentList )? <RPAR>
ArgumentList ::= Argument ( <VIRG> Argument )*
Argument ::= ( <ID> | <STRING> | <INTEGER> )
ArrayAccess ::= <ID> "[" Index "]"
ScalarAccess ::= <ID> ( "." <SIZE> )?



/*Index ::= <ID> | <INTEGER>*/
void Index(): {}
{
  <ID > | < INTEGER >
}