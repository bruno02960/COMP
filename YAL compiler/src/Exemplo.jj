options
{
 LOOKAHEAD=1;
}

PARSER_BEGIN(Exemplo)
import java.io.FileInputStream;
import java.io.IOException;

//código Java que invoca o parser 
public class Exemplo 
{ 
        public static void main(String args[]) throws ParseException, IOException
        {
                //criação do objecto utilizando o constructor com argumento para 
                //ler do standard input (teclado) 
                Exemplo parser = new Exemplo(new FileInputStream("src/test.yal"));
                parser.Module();

                //Scanner TokenManager;
        }
}

PARSER_END(Exemplo)

// definição dos tokens (símbolos terminais) 
<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

//Non-terminals
/* Module ::= <MODULE> <ID> <LCHAVETA> ( Declaration )* ( Function )* <RCHAVETA> */
void Module(): { }
{
	< MODULE > < ID > < LCHAVETA > ( Declaration() )* ( Function() )* < RCHAVETA >
}

/* Declaration ::= ( ArrayElement | ScalarElement ) ( <ASSIGN> ( ( "[" ArraySize "]" ) | (<ADDSUB_OP> )? <INTEGER> ) )? <PVIRG> */
void Declaration(): { }
{
	(LOOKAHEAD(2) ArrayElement() | ScalarElement() ) ( < ASSIGN > (( "[" ArraySize() "]" ) | (< ADDSUB_OP >)? < INTEGER > ))? < PVIRG >
}

/* Function ::= ( ( <FUNCTION> ( ArrayElement | ScalarElement ) <ASSIGN> <ID> <LPAR> (Varlist )? <RPAR> ) | ( <FUNCTION> <ID> <LPAR> ( Varlist )? <RPAR> ) )<LCHAVETA> Stmtlst <RCHAVETA> */
void Function(): { }
{
	(LOOKAHEAD(3) ( < FUNCTION > (LOOKAHEAD(2) ArrayElement() | ScalarElement() ) < ASSIGN > < ID > < LPAR > (Varlist())? < RPAR > )
	| ( < FUNCTION > < ID > < LPAR > ( Varlist() )? < RPAR > )) < LCHAVETA > Stmtlst() < RCHAVETA >
}

/* Varlist ::= ( ArrayElement | ScalarElement ) ( <VIRG> ( ArrayElement | ScalarElement ))* */
void Varlist(): { }
{
	( LOOKAHEAD(2) ArrayElement() | ScalarElement() ) (< VIRG > < ID > ( LOOKAHEAD(2) ArrayElement() | ScalarElement() ))*
}

/* ArrayElement ::= <ID> "[" "]" */
void ArrayElement(): { }
{
	< ID > "[" "]"
}


/*ScalarElement ::= <ID>*/
void ScalarElement(): { }
{
  < ID >
}

/* Stmtlst ::= ( Stmt )* */
void Stmtlst(): { }
{
	( Stmt() )*
}

/* Stmt ::= While | If | Assign | Call <PVIRG> */
void Stmt(): { }
{
    
	While() | If() | LOOKAHEAD(3) Assign() | Call() < PVIRG >
}


/* Assign ::= Lhs <ASSIGN> Rhs <PVIRG> */
void Assign(): { }
{
	Lhs() < ASSIGN > Rhs() < PVIRG >
}

/* Lhs ::= ArrayAccess | ScalarAccess */
void Lhs(): { }
{
	LOOKAHEAD(2) ArrayAccess() | ScalarAccess()
}

/* Rhs ::= ( Term ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term )? ) | "[" ArraySize "]" */
void Rhs(): { }
{
	( Term() ( ( < ARITH_OP > | < BITWISE_OP > | < ADDSUB_OP > ) Term() )? ) | "[" ArraySize() "]"
}

/* ArraySize ::= ScalarAccess | <INTEGER> */
void ArraySize(): { }
{
	ScalarAccess() | < INTEGER >
}

/* Term ::= ( <ADDSUB_OP> )? ( <INTEGER> | Call | ArrayAccess | ScalarAccess ) */
void Term(): { }
{
	( < ADDSUB_OP > )? (< INTEGER > | LOOKAHEAD(3) Call() | LOOKAHEAD(2) ArrayAccess() | ScalarAccess())
}


/* Exprtest ::= <LPAR> Lhs <RELA_OP> Rhs <RPAR> */
void Exprtest(): { }
{
	< LPAR > Lhs() < RELA_OP > Rhs() < RPAR >
}

/*While ::= <WHILE> Exprtest <LCHAVETA> Stmtlst <RCHAVETA> */
void While(): { }
{
	< WHILE > Exprtest() < LCHAVETA > Stmtlst() < RCHAVETA >
}

/*If ::= <IF> Exprtest <LCHAVETA> Stmtlst <RCHAVETA> ( <ELSE> <LCHAVETA> Stmtlst <RCHAVETA> )? */
void If(): { }
{
	< IF > Exprtest() < LCHAVETA > Stmtlst() < RCHAVETA > (< ELSE > < LCHAVETA > Stmtlst() < RCHAVETA >)?
}

/*Call ::= <ID> ( "." <ID> )? <LPAR> ( ArgumentList )? <RPAR> */				
void Call(): { }
{
	< ID > ("." < ID >)? < LPAR > (ArgumentList())? < RPAR > 
}


/* ArgumentList ::= Argument ( <VIRG> Argument )* */
void ArgumentList(): { }
{
	Argument() (< VIRG > Argument())*
}

/* Argument ::= ( <ID> | <STRING> | <INTEGER> ) */
void Argument(): { }
{
	( < ID > | < STRING > | < INTEGER >	)
}

/* ArrayAccess ::= <ID> "[" Index "]"*/
void ArrayAccess(): { }
{
  < ID > "[" Index() "]"
}

/* ScalarAccess ::= <ID> ( "." <SIZE> )? */
void ScalarAccess(): { }
{
  < ID > ("." < SIZE > )?
}

/*Index ::= <ID> | <INTEGER>*/
void Index(): {}
{
  <ID > | < INTEGER >
}